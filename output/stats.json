{
  "2025-11-30": "Given a pandas DataFrame containing at least four numerical features (`feature_A`, `feature_B`, `feature_C`, `feature_D`):\n1.  Create two new interaction features: `interaction_AB` (the product of `feature_A` and `feature_B`) and `interaction_CD` (the product of `feature_C` and `feature_D`).\n2.  Identify all numerical features (original and new) that have a skewness value greater than 0.75.\n3.  For each identified skewed feature, apply a `np.log1p` transformation, replacing the original feature column with its transformed version.\n4.  Display the head of the modified DataFrame and the skewness of all features after transformation.",
  "2025-12-01": "1. Generate a synthetic classification dataset using `sklearn.datasets.make_classification` with at least 1000 samples, 5 numerical features, and 2 categorical features (one with 3 unique values, one with 5 unique values). Introduce missing values (e.g., `np.nan`) into two of the numerical features.\n2. Create an `sklearn.compose.ColumnTransformer` to preprocess the data:\n    *   For numerical features: Impute missing values with the mean, then apply `StandardScaler`.\n    *   For categorical features: Apply `OneHotEncoder`.\n3. Construct an `sklearn.pipeline.Pipeline` that first applies this `ColumnTransformer` and then trains a `RandomForestClassifier`.\n4. Evaluate the complete pipeline's performance using 5-fold cross-validation (`sklearn.model_selection.cross_val_score`) and report the mean accuracy and its standard deviation.",
  "2025-12-02": "1. Create an in-memory SQLite database using the `sqlite3` module.\n2. Create two tables: `customers` (columns: `customer_id` (INTEGER PRIMARY KEY), `name` (TEXT), `city` (TEXT)) and `orders` (columns: `order_id` (INTEGER PRIMARY KEY), `customer_id` (INTEGER), `amount` (REAL), `order_date` (TEXT)). Ensure `customer_id` in `orders` is a foreign key referencing `customers`.\n3. Insert sample data into both tables (at least 5 distinct customers and 10-15 orders, ensuring some customers have multiple orders).\n4. Using a single SQL query, calculate the total purchase `amount` for each customer, retrieving the customer's `name` and their `total_revenue`, joining the `customers` and `orders` tables.\n5. Retrieve these aggregated results directly into a pandas DataFrame and display the top 3 customers by their `total_revenue`.",
  "2025-12-03": "1. Generate a synthetic regression dataset using `sklearn.datasets.make_regression` with at least 500 samples and 5 features.\n2. Create an `sklearn.pipeline.Pipeline` that first applies `StandardScaler` to the features and then fits a `Ridge` regressor.\n3. Define a hyperparameter grid for the `Ridge` regressor within the pipeline, tuning the `alpha` parameter across at least 3 distinct values (e.g., `[0.1, 1.0, 10.0]`).\n4. Use `sklearn.model_selection.GridSearchCV` with the pipeline and the defined parameter grid to find the best hyperparameters. Use `neg_mean_squared_error` as the scoring metric and apply 3-fold cross-validation.\n5. Report the best hyperparameters found by `GridSearchCV` and the corresponding best score (remembering to convert the `neg_mean_squared_error` back to a positive MSE value).",
  "2025-12-04": "1. Generate a synthetic dataset using `sklearn.datasets.make_blobs` with at least 500 samples, 4 numerical features, and 3 distinct clusters. Convert this into a pandas DataFrame, including the cluster labels as a feature (e.g., `cluster_id`).\n2. Add a new categorical feature to the DataFrame (e.g., `group`) with 2-3 distinct values, randomly assigned.\n3. Using `seaborn` and `matplotlib.pyplot`, create the following visualizations to explore the data:\n    *   A pair plot (`sns.pairplot`) for the numerical features, coloring the points by the `cluster_id`.\n    *   A set of histograms (or KDE plots) for `feature_1` and `feature_2`, separated for each unique value of the newly created `group` categorical feature (e.g., using `sns.FacetGrid` or `sns.histplot` with `hue` and `col`).\n    *   A box plot (or violin plot) showing the distribution of `feature_3` across the different `cluster_id`s.\n4. Ensure all plots have appropriate titles and labels.",
  "2025-12-05": "1. Generate a synthetic binary classification dataset using `sklearn.datasets.make_classification` (e.g., 1000 samples, 10 features, 2 informative features, 2 classes).\n2. Split the dataset into training and testing sets (e.g., 80/20 split) using `train_test_split`.\n3. Train a `LogisticRegression` model on the training data.\n4. Predict class labels and class probabilities for the positive class on the test set.\n5. Calculate and print the following evaluation metrics for the test set predictions: Accuracy, Precision, Recall, F1-score, and ROC AUC score.\n6. Plot the Receiver Operating Characteristic (ROC) curve for the model using `matplotlib.pyplot`, clearly labeling axes and adding a title. Include the AUC score in the plot legend.",
  "2025-12-06": "1. Generate a synthetic regression dataset using `sklearn.datasets.make_regression` with at least 500 samples, 3 informative features, and a small amount of noise.\n2. Create two distinct `sklearn.pipeline.Pipeline` objects:\n    *   `pipeline_simple`: Consisting of `StandardScaler` followed by `LinearRegression`.\n    *   `pipeline_poly`: Consisting of `PolynomialFeatures` (set `degree=2`), then `StandardScaler`, then `LinearRegression`.\n3. Evaluate both pipelines using `sklearn.model_selection.cross_val_score` with 5-fold cross-validation and `neg_mean_squared_error` as the scoring metric.\n4. Print the mean and standard deviation of the Mean Squared Error (MSE) for both pipelines, clearly indicating which result belongs to which pipeline. (Remember to convert `neg_mean_squared_error` to positive MSE values for interpretability).",
  "2025-12-07": "1. Generate a pandas DataFrame with a `timestamp` column (daily data for 2-3 years) and a `value` column (e.g., synthetic sales data with some trend and seasonality, using `np.sin` or similar).\n2. From the `timestamp` column, create new features: `month` (numerical month), `day_of_week` (name of the day, e.g., 'Monday'), and `is_weekend` (boolean).\n3. Calculate the average `value` aggregated by `month` and by `day_of_week`.\n4. Create two visualizations using `seaborn` and `matplotlib.pyplot`:\n    *   A line plot showing the average `value` trend across months.\n    *   A bar plot showing the average `value` for each `day_of_week`.\n5. Display the head of the DataFrame with the new features and print the aggregated dataframes for both monthly and daily trends."
}